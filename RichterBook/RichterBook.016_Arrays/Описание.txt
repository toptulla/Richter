CRL поддерживает 3 вида массивов:
single-dimension
mulltidimension
jagged

Базовым является abstract класс Syste.Array (=> массивы всегда относятся к ссылочному типу и размещаются в УК,
а переменная содержит не элементы массива, а ссылку на объект массива в УК).

-----------
Пример:
Int32[] myIntegers;
myIntegers = new Int32[100];

В 1-й строке объявляется переменная myIntegers, вначале ей присваивается значение null (т.к. память под массив пока
не выделенна).
Во 2-й строке выделяется память под 100 значений типа Int32, всем им присваивается значение 0. Этот блок памяти
также содержит указатель на объект типа и индекс блока синхронизации, как и любой объект ссылочного типа, плюс
некоторые дополнительные члены. Затем переменной присваивается адрес этого блока памяти.
-----------

Согласно CLS, нумерация элементов в массива начинается с 0.

К дополнительной информации, хранящейся в выделенном блоке памяти относятся сведения о размерности массива, нижних
границах всех его измерений (почти всегда 0) и количестве элементов в каждом измерении. Кроме того там хранится
информация о типе элементов массива.

По возможности используйте только одномерные массивы с нулевым начальным индексом, которые иногда называются
SZ-массивами, или векторами. Векторы обеспечивают наилучшую производительность, т.к. для операций с ними
используются команды IL, например, newarr, ldelem, ldelema, ldlen, stelem.

Многомерный массив:
Int32[,] myIntegers = new Int32[10,2];

Нерегулярный массив:
Int32[][] arr = new Int32[10][];
arr[0] = new Int32[2];
arr[1] = new Int32[2];

CLR проверяет корректность индексов - выход индекса за пределы массива. Попытка обратиться к массиву длинной 100, по
индексу -5 или 100 приведет к System.Index.OutOfRangeException. Компилятор выполняет ее только 1 раз, перед началом
цикла, а не на каждой итерации. Впрочем, если все-таки эта проверка критична для вашей программы, то используйте для
доступа к массиву небезопасный код.

В CLR для массивов ссылочного типа допустимо приведение. При этом оба массива должны иметь одинаковую размерность, а
также, должно иметь место неявное преобразование из типа элементов исходного массива в целевой тип. CLR не
поддерживает преобразование массивов с элементами значимых типов в другие.
Вот так сделать не получится:
int[] a = new int[2];
object[] o = a;